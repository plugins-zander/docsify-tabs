{"version":3,"file":"docsify-tabs.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/js/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Dependencies\n// =============================================================================\nimport { version as pkgVersion } from '../../package.json';\nimport '../scss/style.scss';\n\n\n// Constants and variables\n// =============================================================================\nconst commentReplaceMark = 'tabs:replace';\nconst classNames = {\n    tabsContainer  : 'content',\n    tabBlock       : 'docsify-tabs',\n    tabButton      : 'docsify-tabs__tab',\n    tabButtonActive: 'docsify-tabs__tab--active',\n    tabContent     : 'docsify-tabs__content'\n};\nconst regex = {\n    // Matches markdown code blocks (inline and multi-line)\n    // Example: ```text```\n    codeMarkup: /(```[\\s\\S]*?```)/gm,\n\n    // Matches tab replacement comment\n    // 0: Match\n    // 1: Replacement HTML\n    commentReplaceMarkup: new RegExp(`<!-- ${commentReplaceMark} (.*) -->`),\n\n    // Matches tab set by start/end comment\n    // 0: Match\n    // 1: Indent\n    // 2: Start comment: <!-- tabs:start -->\n    // 3: Labels and content\n    // 4: End comment: <!-- tabs:end -->\n    tabBlockMarkup: /[\\r\\n]*(\\s*)(<!-+\\s+tabs:\\s*?start\\s+-+>)[\\r\\n]+([\\s|\\S]*?)[\\r\\n\\s]+(<!-+\\s+tabs:\\s*?end\\s+-+>)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: <!-- tab:Label -->\n    // 2: Content\n    tabCommentMarkup: /[\\r\\n]*(\\s*)<!-+\\s+tab:\\s*(.*)\\s+-+>[\\r\\n]+([\\s\\S]*?)[\\r\\n]*\\s*(?=<!-+\\s+tabs?:)/m,\n\n    // Matches tab label and content\n    // 0: Match\n    // 1: Label: #### **Label** OR #### __Label__\n    // 2: Content\n    tabHeadingMarkup: /[\\r\\n]*(\\s*)#{1,6}\\s*[*_]{2}\\s*(.*[^\\s])\\s*[*_]{2}[\\r\\n]+([\\s\\S]*?)(?=#{1,6}\\s*[*_]{2}|<!-+\\s+tabs:\\s*?end\\s+-+>)/m\n};\nconst settings = {\n    persist    : true,\n    sync       : true,\n    theme      : 'classic',\n    tabComments: true,\n    tabHeadings: true\n};\n\n\n// Functions\n// =============================================================================\n/**\n * Converts tab content into \"stage 1\" markup. Stage 1 markup contains temporary\n * comments which are replaced with HTML during Stage 2. This approach allows\n * all markdown to be converted to HTML before tab-specific HTML is added.\n *\n * @param {string} content\n * @returns {string}\n */\nfunction renderTabsStage1(content) {\n    const codeBlockMatch   = content.match(regex.codeMarkup) || [];\n    const codeBlockMarkers = codeBlockMatch.map((item, i) => {\n        const codeMarker = `<!-- ${commentReplaceMark} CODEBLOCK${i} -->`;\n\n        // Replace code block with marker to ensure tab markup within code\n        // blocks is not processed. These markers are replaced with their\n        // associated code blocs after tabs have been processed.\n        content = content.replace(item, () => codeMarker);\n\n        return codeMarker;\n    });\n    const tabTheme = settings.theme ? `${classNames.tabBlock}--${settings.theme}` : '';\n\n    let tabBlockMatch; // eslint-disable-line no-unused-vars\n    let tabMatch; // eslint-disable-line no-unused-vars\n\n    // Process each tab set\n    while ((tabBlockMatch = regex.tabBlockMarkup.exec(content)) !== null) {\n        let tabBlock            = tabBlockMatch[0];\n        let tabStartReplacement = '';\n        let tabEndReplacement   = '';\n\n        const hasTabComments = settings.tabComments && regex.tabCommentMarkup.test(tabBlock);\n        const hasTabHeadings = settings.tabHeadings && regex.tabHeadingMarkup.test(tabBlock);\n        const tabBlockIndent = tabBlockMatch[1];\n        const tabBlockStart  = tabBlockMatch[2];\n        const tabBlockEnd    = tabBlockMatch[4];\n\n        if (hasTabComments || hasTabHeadings) {\n            tabStartReplacement = `<!-- ${commentReplaceMark} <div class=\"${[classNames.tabBlock, tabTheme].join(' ')}\"> -->`;\n            tabEndReplacement = `\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`;\n\n            // Process each tab panel\n            while ((tabMatch = (settings.tabComments ? regex.tabCommentMarkup.exec(tabBlock) : null) || (settings.tabHeadings ? regex.tabHeadingMarkup.exec(tabBlock) : null)) !== null) {\n                const tabTitle   = (tabMatch[2] || '[Tab]').trim();\n                const tabContent = (tabMatch[3] || '').trim();\n\n                // Use replace function to avoid regex special replacement\n                // strings being processed ($$, $&, $`, $', $n)\n                tabBlock = tabBlock.replace(tabMatch[0], () => [\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <button class=\"${classNames.tabButton}\" data-tab=\"${tabTitle.toLowerCase()}\">${tabTitle}</button> -->`,\n                    `\\n${tabBlockIndent}<!-- ${commentReplaceMark} <div class=\"${classNames.tabContent}\" data-tab-content=\"${tabTitle.toLowerCase()}\"> -->`,\n                    `\\n\\n${tabBlockIndent}${tabContent}`,\n                    `\\n\\n${tabBlockIndent}<!-- ${commentReplaceMark} </div> -->`,\n                ].join(''));\n            }\n        }\n\n        tabBlock = tabBlock.replace(tabBlockStart, () => tabStartReplacement);\n        tabBlock = tabBlock.replace(tabBlockEnd, () => tabEndReplacement);\n        content = content.replace(tabBlockMatch[0], () => tabBlock);\n    }\n\n    // Restore code blocks\n    codeBlockMarkers.forEach((item, i) => {\n        content = content.replace(item, () => codeBlockMatch[i]);\n    });\n\n    return content;\n}\n\n/**\n * Converts \"stage 1\" markup into final markup by replacing temporary comments\n * with HTML.\n *\n * @param {string} html\n * @returns {string}\n */\nfunction renderTabsStage2(html) {\n    let tabReplaceMatch; // eslint-disable-line no-unused-vars\n\n    while ((tabReplaceMatch = regex.commentReplaceMarkup.exec(html)) !== null) {\n        const tabComment     = tabReplaceMatch[0];\n        const tabReplacement = tabReplaceMatch[1] || '';\n\n        html = html.replace(tabComment, () => tabReplacement);\n    }\n\n    return html;\n}\n\n/**\n * Sets the initial active tab for each tab group: the tab containing the\n * matching element ID from the URL, the first tab in the group, or the last tab\n * clicked (if persist option is enabled).\n */\nfunction setDefaultTabs() {\n    const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n    const tabBlocks         = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n    const tabStoragePersist = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n    const tabStorageSync    = JSON.parse(sessionStorage.getItem('*')) || [];\n\n    setActiveTabFromAnchor();\n\n    tabBlocks.forEach((tabBlock, index) => {\n        let activeButton = tabBlock.querySelector(`.${classNames.tabButtonActive}`);\n\n        if (!activeButton) {\n            if (settings.sync && tabStorageSync.length) {\n                activeButton = tabStorageSync\n                    .map(label => tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${label}\"]`))\n                    .filter(elm => elm)[0];\n            }\n\n            if (!activeButton && settings.persist) {\n                activeButton = tabBlock.querySelector(`.${classNames.tabButton}[data-tab=\"${tabStoragePersist[index]}\"]`);\n            }\n\n            activeButton = activeButton || tabBlock.querySelector(`.${classNames.tabButton}`);\n            activeButton && activeButton.classList.add(classNames.tabButtonActive);\n        }\n    });\n}\n\n/**\n * Sets the active tab within a group. Optionally stores the selection so it can\n * persist across page loads and syncs active state to tabs with same data attr.\n *\n * @param {object} elm Tab toggle element to mark as active\n */\nfunction setActiveTab(elm, _isMatchingTabSync = false) {\n    const isTabButton = elm.classList.contains(classNames.tabButton);\n\n    if (isTabButton) {\n        const activeButton      = elm;\n        const activeButtonLabel = activeButton.getAttribute('data-tab');\n        const tabsContainer     = document.querySelector(`.${classNames.tabsContainer}`);\n        const tabBlock          = activeButton.parentNode;\n        const tabButtons        = Array.apply(null, tabBlock.querySelectorAll(`.${classNames.tabButton}`));\n        const tabBlockOffset    = tabBlock.offsetTop;\n\n        tabButtons.forEach(buttonElm => buttonElm.classList.remove(classNames.tabButtonActive));\n        activeButton.classList.add(classNames.tabButtonActive);\n\n        if (!_isMatchingTabSync) {\n            if (settings.persist) {\n                const tabBlocks     = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabBlock}`)) : [];\n                const tabBlockIndex = tabBlocks.indexOf(tabBlock);\n                const tabStorage    = JSON.parse(sessionStorage.getItem(window.location.href)) || {};\n\n                tabStorage[tabBlockIndex] = activeButtonLabel;\n                sessionStorage.setItem(window.location.href, JSON.stringify(tabStorage));\n            }\n\n            if (settings.sync) {\n                const tabButtonMatches = tabsContainer ? Array.apply(null, tabsContainer.querySelectorAll(`.${classNames.tabButton}[data-tab=\"${activeButtonLabel}\"]`)) : [];\n                const tabStorage       = JSON.parse(sessionStorage.getItem('*')) || [];\n\n                tabButtonMatches.forEach(tabButtonMatch => {\n                    setActiveTab(tabButtonMatch, true);\n                });\n\n                // Maintain position in viewport when tab group's offset changes\n                window.scrollBy(0, 0 - (tabBlockOffset - tabBlock.offsetTop));\n\n                // Remove existing label if not first in array\n                if (tabStorage.indexOf(activeButtonLabel) > 0) {\n                    tabStorage.splice(tabStorage.indexOf(activeButtonLabel), 1);\n                }\n\n                // Add label if not already in first position\n                if (tabStorage.indexOf(activeButtonLabel) !== 0) {\n                    tabStorage.unshift(activeButtonLabel);\n                    sessionStorage.setItem('*', JSON.stringify(tabStorage));\n                }\n            }\n        }\n    }\n}\n\n/**\n * Sets the active tab based on the anchor ID in the URL\n */\nfunction setActiveTabFromAnchor() {\n    const anchorID              = (window.location.hash.match(/(?:id=)([^&]+)/) || [])[1];\n    const anchorSelector        = anchorID && `.${classNames.tabBlock} #${anchorID.indexOf('%') > -1 ? decodeURIComponent(anchorID) : anchorID}`;\n    const isAnchorElmInTabBlock = anchorID && document.querySelector(anchorSelector);\n\n    if (isAnchorElmInTabBlock) {\n        const anchorElm = document.querySelector(`#${anchorID}`);\n\n        let tabContent;\n\n        if (anchorElm.closest) {\n            tabContent = anchorElm.closest(`.${classNames.tabContent}`);\n        }\n        else {\n            tabContent = anchorElm.parentNode;\n\n            while (tabContent !== document.body && !tabContent.classList.contains(`${classNames.tabContent}`)) {\n                tabContent = tabContent.parentNode;\n            }\n        }\n\n        setActiveTab(tabContent.previousElementSibling);\n    }\n}\n\n\n// Plugin\n// =============================================================================\nfunction docsifyTabs(hook, vm) {\n    let hasTabs = false;\n\n    hook.beforeEach(function(content) {\n        hasTabs = regex.tabBlockMarkup.test(content);\n\n        if (hasTabs) {\n            content = renderTabsStage1(content);\n        }\n\n        return content;\n    });\n\n    hook.afterEach(function(html, next) {\n        if (hasTabs) {\n            html = renderTabsStage2(html);\n        }\n\n        next(html);\n    });\n\n    hook.doneEach(function() {\n        if (hasTabs) {\n            setDefaultTabs();\n        }\n    });\n\n    hook.mounted(function() {\n        const tabsContainer = document.querySelector(`.${classNames.tabsContainer}`);\n\n        tabsContainer && tabsContainer.addEventListener('click', function(evt) {\n            setActiveTab(evt.target);\n        });\n\n        window.addEventListener('hashchange', setActiveTabFromAnchor, false);\n    });\n}\n\n\nif (window) {\n    window.$docsify = window.$docsify || {};\n\n    // Add config object\n    window.$docsify.tabs = window.$docsify.tabs || {};\n\n    // Update settings based on $docsify config\n    Object.keys(window.$docsify.tabs).forEach(key => {\n        if (Object.prototype.hasOwnProperty.call(settings, key)) {\n            settings[key] = window.$docsify.tabs[key];\n        }\n    });\n\n    // Add plugin data\n    window.$docsify.tabs.version = pkgVersion;\n\n    // Init plugin\n    if (settings.tabComments || settings.tabHeadings) {\n        window.$docsify.plugins = [].concat(\n            docsifyTabs,\n            (window.$docsify.plugins || [])\n        );\n    }\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","commentReplaceMark","classNames","tabsContainer","tabBlock","tabButton","tabButtonActive","tabContent","regex","codeMarkup","commentReplaceMarkup","RegExp","tabBlockMarkup","tabCommentMarkup","tabHeadingMarkup","settings","persist","sync","theme","tabComments","tabHeadings","renderTabsStage1","content","codeBlockMatch","match","codeBlockMarkers","map","item","i","codeMarker","replace","tabTheme","tabBlockMatch","tabMatch","tabStartReplacement","tabEndReplacement","hasTabComments","test","hasTabHeadings","tabBlockIndent","tabBlockStart","tabBlockEnd","join","tabTitle","trim","toLowerCase","exec","forEach","renderTabsStage2","html","tabReplaceMatch","tabComment","tabReplacement","setDefaultTabs","querySelector","tabBlocks","Array","apply","querySelectorAll","tabStoragePersist","JSON","parse","sessionStorage","getItem","window","location","href","tabStorageSync","setActiveTabFromAnchor","index","activeButton","length","label","filter","elm","classList","add","setActiveTab","_isMatchingTabSync","isTabButton","contains","activeButtonLabel","getAttribute","parentNode","tabButtons","tabBlockOffset","offsetTop","buttonElm","remove","tabBlockIndex","indexOf","tabStorage","setItem","stringify","tabButtonMatches","tabButtonMatch","scrollBy","splice","unshift","anchorID","hash","anchorSelector","decodeURIComponent","isAnchorElmInTabBlock","anchorElm","closest","body","previousElementSibling","docsifyTabs","hook","vm","hasTabs","beforeEach","afterEach","next","doneEach","mounted","addEventListener","evt","target","$docsify","tabs","Object","keys","key","prototype","hasOwnProperty","call","version","pkgVersion","plugins","concat"],"mappings":"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"}